// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.17;

import "forge-std/Test.sol";
import {ProposalRefEncoder} from "@libs/ProposalRefEncoder.sol";

contract TestHelpers is Test {
    address constant OSX_ANY_ADDR = address(type(uint160).max);

    bytes ownableError = "Ownable: caller is not the owner";
    bytes initializableError = "Initializable: contract is already initialized";

    /// @dev forge will revert tests with large numbers of failed runs during fuzzing. This also
    /// hurts performance. If you find that you are getting a lot of failed runs, you can use this
    /// to ensure that the proposal id encodes a valid sequence of timestamps.
    /// @dev Be careful to ensure this is used in conjunction with tests that check for true randomness.
    /// Anybody can put anything into proposal.
    /// @param _proposalSeed A random number, typically generated by the fuzzing engine. Can be discarded once used.
    /// @return _proposalRef A valid proposal ref that can be used in tests that require progressive timestamps.
    function _makeValidProposalRefFromSeed(uint _proposalSeed) internal pure returns (uint) {
        // destructure the proposal seed
        (
            uint32 proposalId,
            uint128 plugin,
            uint32 _startTs,
            uint32 _endTs,
            uint32 _snapshotTs
        ) = ProposalRefEncoder.decode(_proposalSeed);

        // the start ts needs to be lte the end ts
        // with a minimum of 2 blocks between them
        // first, at the boundry ensure that end is greater than start
        if (_startTs >= _endTs) {
            // these 2 cases require checking to prevent underflow
            if (_startTs == 0) {
                _endTs = 2;
            } else if (_startTs == 1) {
                _startTs = 0;
                _endTs = 2;
                // this is all other cases where start is greater than end
            } else {
                _endTs = _startTs;
                _startTs = _endTs - 2;
            }
        }

        // now we just check that there is at least 2 blocks between them
        if (_endTs - _startTs == 1) {
            // if there is no space to add to the end, remove from the start
            if (_endTs == type(uint32).max) {
                _startTs = _endTs - 2;
                // else just bump the end
            } else {
                _endTs = _startTs + 2;
            }
        }

        // the snapshot ts needs to be lte the start ts
        if (_snapshotTs > _startTs) {
            _snapshotTs = _startTs;
        }

        // now write it back
        uint256 proposalRef = ProposalRefEncoder.encode(
            proposalId,
            plugin,
            _startTs,
            _endTs,
            _snapshotTs
        );

        return proposalRef;
    }

    /// @notice checks that the proposal has a valid timestamp that can be warped to and go there
    function _warpToValidTs(uint256 _proposalRef, uint32 _warpTo) internal {
        (, , uint32 _startTs, uint32 _endTs, uint32 _snapshotTs) = ProposalRefEncoder.decode(
            _proposalRef
        );

        vm.assume(_snapshotTs <= _startTs);
        vm.assume(_startTs < _warpTo);
        vm.assume(_endTs > _warpTo);

        vm.warp(_warpTo);
    }
}
