// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import {ProposalIdCodec} from "@libs/ProposalIdCodec.sol";

contract TestHelpers is Test {
    /// @dev forge will revert tests with large numbers of failed runs during fuzzing. This also
    /// hurts performance. If you find that you are getting a lot of failed runs, you can use this
    /// to ensure that the proposal id encodes a valid sequence of timestamps.
    /// @dev Be careful to ensure this is used in conjunction with tests that check for true randomness.
    /// Anybody can put anything into proposal.
    /// @param _proposalSeed A random number, typically generated by the fuzzing engine. Can be discarded once used.
    /// @return _proposalId A valid proposal id that can be used in tests that require progressive ti
    function _makeValidProposalIdFromSeed(uint _proposalSeed) internal pure returns (uint) {
        // destructure the proposal seed
        (address plugin, uint32 _startTs, uint32 _endTs, uint32 _snapshotTs) = ProposalIdCodec
            .decode(_proposalSeed);

        // the start ts needs to be lte the end ts
        // with a minimum of 2 blocks between them
        if (_startTs >= _endTs) {
            if (_startTs == 0) {
                _endTs = 2;
            } else if (_startTs == 1) {
                _startTs = 0;
                _endTs = 2;
            } else {
                _endTs = _startTs;
                _startTs = _endTs - 2;
            }
        }

        // this covers the final edge case, based on above
        // start ts will be 0, end will be 1, so we need to bump it up
        if (_endTs == 1) {
            _endTs = 2;
        }

        // the snapshot ts needs to be lte the start ts
        if (_snapshotTs > _startTs) {
            _snapshotTs = _startTs;
        }

        // now write it back
        uint256 _proposalId = ProposalIdCodec.encode(plugin, _startTs, _endTs, _snapshotTs);

        return _proposalId;
    }

    /// @notice checks that the proposal has a valid timestamp that can be warped to and go there
    function _warpToValidTs(uint256 _proposalId, uint32 _warpTo) internal {
        (, uint32 _startTs, uint32 _endTs, uint32 _snapshotTs) = ProposalIdCodec.decode(
            _proposalId
        );

        vm.assume(_snapshotTs <= _startTs);
        vm.assume(_startTs < _warpTo);
        vm.assume(_endTs > _warpTo);

        vm.warp(_warpTo);
    }
}
